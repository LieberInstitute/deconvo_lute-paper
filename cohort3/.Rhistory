zrefMapped[geneName,mappedLabel]==rowMeans(
zref[,which(colnames(zref) %in% mappingsTable[mappingsTable[,2]==mappedLabel,1])]
)[geneName]
# test gene NRG1, label Monocyte
geneName <- "NRG1"
zrefMapped[geneName,mappedLabel]==rowMeans(
zref[,which(colnames(zref) %in% mappingsTable[mappingsTable[,2]==mappedLabel,1])]
)[geneName]
#
# test label Plasma
mappedLabel <- "Plasma"
# test gene FXYD6, label Plasma
geneName <- "FXYD6"
zrefMapped[geneName,mappedLabel]==
zref[,which(colnames(zref) %in%
mappingsTable[mappingsTable[,2]==mappedLabel,1])][
which(rownames(zref)==geneName)]
# test gene NRG1, label Plasma
geneName <- "NRG1"
zrefMapped[geneName,mappedLabel]==
zref[,which(colnames(zref) %in%
mappingsTable[mappingsTable[,2]==mappedLabel,1])][
which(rownames(zref)==geneName)]
# parse true proportions
#
#
#
# format from supplement
trueProportionsStart <- fc.proportions
rownames(trueProportionsStart) <- sampleNames <- fc.proportions[,1]
trueProportionsStart <- trueProportionsStart[,c(2:ncol(trueProportionsStart))]
trueProportionsStart <- trueProportionsStart[
,colnames(trueProportionsStart) %in% colnames(zref)]
# get fractions <1
trueProportionsStart <- t(apply(
trueProportionsStart, 1, function(ri){ri/sum(ri)}))
trueProportionsStart <- as.data.frame(trueProportionsStart)
rownames(trueProportionsStart) <- sampleNames
# map labels
trueproportionsMapped <- cellLabelMappings(
vectorCellTypeMap, colnames(trueProportionsStart),
trueProportionsStart, returnType = "df", summaryOperation = "sum")
trueproportionsMapped <- trueproportionsMapped[
,!colnames(trueproportionsMapped)=="NA"]
# get fractions <1
trueproportionsMapped <- t(apply(
trueproportionsMapped, 1, function(ri){ri/sum(ri)}))
trueproportionsMapped <- as.data.frame(trueproportionsMapped)
rownames(trueproportionsMapped) <- sampleNames
# tests -- proportions
#
#
# test original proportions table
length(which(rowSums(trueProportionsStart)==1))==
nrow(trueProportionsStart)
#
# test new proportions table
length(which(round(rowSums(trueproportionsMapped),1)==1))==
nrow(trueproportionsMapped)
# parse cell type sizes
#
#
#
#
cellFactorsOriginal <- matrix(df.tall$s.cell.size,nrow=1)
colnames(cellFactorsOriginal) <- df.tall$cell.type
cellFactorsOriginal <- as.data.frame(cellFactorsOriginal)
dfCellScaleFactors <- cellLabelMappings(
vectorCellTypeMap=vectorCellTypeMap,
vectorCellTypeStart=cellFactorsOriginal$cellTypesOriginal,
dfToMap=cellFactorsOriginal, returnType = "df",
summaryOperation = "mean"
)
cellScaleFactors <- as.numeric(dfCellScaleFactors)
names(cellScaleFactors) <- colnames(dfCellScaleFactors)
cellScaleFactors <- cellScaleFactors[!names(cellScaleFactors)=="NA"]
# test
#
#
#---------------
# run experiment
#---------------
bulkExpression <- as.matrix(assays(se)[["tpm"]])
bulkExpression <- bulkExpression[
rownames(bulkExpression) %in% rownames(zref),]
colnames(bulkExpression) <- gsub("_.*", "", colnames(bulkExpression))
referenceExpression <- zrefMapped
referenceExpression <- referenceExpression[
rownames(referenceExpression) %in% rownames(bulkExpression),]
trueCellTypeProportions <- trueproportionsMapped
colnames(trueCellTypeProportions) <-
paste0(colnames(trueCellTypeProportions), ".true")
trueCellTypeProportions$sample.id <- rownames(trueCellTypeProportions)
# get experiment results
#experimentList <- newExperimentList(
#  referenceExpression=referenceExpression,
#  trueCellTypeProportions=trueCellTypeProportions,
#  cellScaleFactors=cellScaleFactors,
#  bulkExpression=bulkExpression,
#  trueCellTypeProportionsSource="Flow cytometry",
#  typemarkerAlgorithmName=NULL
#)
#experimentResults <- evaluateExperiment(
#  experimentList, TRUE
#)
#--------------------------
# get the expression tables
#--------------------------
tpmReference <- zref
log2TpmReference <-
apply(
tpmReference, 2,
function(cellName){log2(cellName+1)}) %>% as.data.frame()
scaleTpmReference <- scale(tpmReference) %>% as.data.frame()
scaleLog2TpmZref <- scale(log2TpmReference) %>% as.data.frame()
#-----
# save
#-----
save.image(file="./env/03_k5/01_run_script.RData")
libraryVector <- c("ggplot2", "reshape2", "dplyr")
sapply(libraryVector, library, character.only = TRUE)
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
load("./env/03_k5/01_run_script.RData")
#------------------
# helper functions
#------------------
# FROM EXPRESSION, GET SIMPLIFIED THRESHOLD PLOT
getQuantileTablesFromReferenceExpression <- function(
expressionTable, quantileThresholdIndex = 4){
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileColumn <- quantile(ci)
labelColumnValues <- ifelse(ci >= quantileColumn[quantileThresholdIndex],
TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
rownames(numericTable) <-
rownames(booleanTable) <- rownames(expressionTable)
# return
returnList <- list(
booleanTable = referenceQuantile, numericTable = numericTable)
return(returnList)
}
# FROM EXPRESSION GET PCA
#
listQuantileTables <-
getQuantileTablesFromReferenceExpression(
tpmReference, quantileThresholdIndex)
listQuantileTables <-
getQuantileTablesFromReferenceExpression(tpmReference)
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileColumn <- quantile(ci)
labelColumnValues <- ifelse(ci >= quantileColumn[quantileThresholdIndex],
TRUE, FALSE)
return(labelColumnValues)
})
quantileThresholdIndex = 4
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileColumn <- quantile(ci)
labelColumnValues <- ifelse(ci >= quantileColumn[quantileThresholdIndex],
TRUE, FALSE)
return(labelColumnValues)
})
booleanTable
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
numericTable
head(numericTable)
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileColumn <- quantile(ci)
labelColumnValues <- ifelse(ci >= quantileColumn[quantileThresholdIndex],
TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
expressionTable=tpmReference
dim(expressionTable)
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileColumn <- quantile(ci)
labelColumnValues <- ifelse(ci >= quantileColumn[quantileThresholdIndex],
TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
rownames(numericTable) <-
rownames(booleanTable) <- rownames(expressionTable)
numericTable
head(numericTable)
head(booleanTable)
Heatmap(numericTable)
library(ComplexHeatmap)
Heatmap(numericTable)
Heatmap(booleanTable)
heatmapNumeric <- Heatmap(numericTable)
# FROM EXPRESSION, GET SIMPLIFIED THRESHOLD PLOT
getQuantileTablesFromReferenceExpression <- function(
expressionTable, heatmapNumericScaleName, quantileThresholdIndex=4){
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileColumn <- quantile(ci)
labelColumnValues <- ifelse(ci >= quantileColumn[quantileThresholdIndex],
TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
rownames(numericTable) <-
rownames(booleanTable) <- rownames(expressionTable)
# heatmaps
heatmapNumeric <- Heatmap(
numericTable, name = heatmapNumericScaleName)
# return
returnList <- list(
booleanTable = referenceQuantile,
numericTable = numericTable,
heatmapNumeric = heatmapNumeric
)
return(returnList)
}
getQuantileTablesFromReferenceExpression <- function(
expressionTable, heatmapNumericScaleName, quantileThresholdIndex=4){
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileColumn <- quantile(ci)
labelColumnValues <- ifelse(ci >= quantileColumn[quantileThresholdIndex],
TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
rownames(numericTable) <-
rownames(booleanTable) <- rownames(expressionTable)
# heatmaps
heatmapNumeric <- Heatmap(
numericTable, name = heatmapNumericScaleName)
# return
returnList <- list(
booleanTable = referenceQuantile,
numericTable = numericTable,
heatmapNumeric = heatmapNumeric
)
return(returnList)
}
getQuantileTablesFromReferenceExpression(tpmReference, "TPM")[[3]]
getQuantileTablesFromReferenceExpression <- function(
expressionTable, heatmapNumericScaleName, quantileThresholdIndex=4){
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileColumn <- quantile(ci)
labelColumnValues <- ifelse(
ci >= quantileColumn[quantileThresholdIndex], TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
rownames(numericTable) <-
rownames(booleanTable) <- rownames(expressionTable)
# heatmaps
heatmapNumeric <- Heatmap(
numericTable, name = heatmapNumericScaleName)
# return
returnList <- list(
booleanTable = booleanTable,
numericTable = numericTable,
heatmapNumeric = heatmapNumeric
)
return(returnList)
}
getQuantileTablesFromReferenceExpression(tpmReference, "TPM")[[3]]
getQuantileTablesFromReferenceExpression(scaleTpmReference, "Z TPM")[[3]]
getQuantileTablesFromReferenceExpression(log2TpmReference, "log2 TPM")[[3]]
getQuantileTablesFromReferenceExpression(scaleLog2TpmZref, "Z log2 TPM")[[3]]
rm(expressionTable)
getQuantileTablesFromReferenceExpression(tpmReference, "TPM")[[3]]
getQuantileTablesFromReferenceExpression(scaleTpmReference, "Z TPM")[[3]]
head(log2TpmReference)
libraryVector <- c("ggplot2", "reshape2", "dplyr")
sapply(libraryVector, library, character.only = TRUE)
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
load("./env/03_k5/01_run_script.RData")
#------------------
# helper functions
#------------------
# FROM EXPRESSION, GET SIMPLIFIED THRESHOLD PLOT
getQuantileTablesFromReferenceExpression <- function(
expressionTable, heatmapNumericScaleName, quantileThresholdIndex=4){
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileColumn <- quantile(ci)
labelColumnValues <- ifelse(
ci >= quantileColumn[quantileThresholdIndex], TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
rownames(numericTable) <-
rownames(booleanTable) <- rownames(expressionTable)
# heatmaps
heatmapNumeric <- Heatmap(
numericTable, name = heatmapNumericScaleName)
# return
returnList <- list(
booleanTable = booleanTable,
numericTable = numericTable,
heatmapNumeric = heatmapNumeric
)
return(returnList)
}
# FROM EXPRESSION GET PCA
#
Heatmap(tpmReference)
Heatmap(tpmReference)
Heatmap(scaleTpmReference)
Heatmap(log2TpmReference)
Heatmap(scaleLog2TpmZref)
tpmReference <- zref
log2TpmReference <-
apply(
tpmReference, 2,
function(cellName){log2(cellName+1)}) %>% as.data.frame()
scaleTpmReference <- scale(tpmReference) %>% as.data.frame()
scaleLog2TpmReference <- scale(log2TpmReference) %>% as.data.frame()
Heatmap(tpmReference)
Heatmap(scaleTpmReference)
Heatmap(log2TpmReference)
Heatmap(scaleLog2TpmReference)
getQuantileTablesFromReferenceExpression(tpmReference, "TPM")[[3]]
getQuantileTablesFromReferenceExpression(scaleTpmReference, "Z TPM")[[3]]
getQuantileTablesFromReferenceExpression(log2TpmReference, "log2 TPM")[[3]]
getQuantileTablesFromReferenceExpression(scaleLog2TpmZref, "Z log2 TPM")[[3]]
seq(0,1,0.25)
?quantile
quantileSeq
getQuantileTablesFromReferenceExpression <- function(
expressionTable, heatmapNumericScaleName, quantileThresholdIndex=4,
quantileSeq=seq(0,1,0.25)){
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileThreshold <-
quantile(ci, probs=quantileSeq)[quantileThresholdIndex]
labelColumnValues <- ifelse(
ci >= quantileThreshold, TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
rownames(numericTable) <-
rownames(booleanTable) <- rownames(expressionTable)
# heatmaps
heatmapNumeric <- Heatmap(
numericTable, name = heatmapNumericScaleName)
# return
returnList <- list(
booleanTable = booleanTable,
numericTable = numericTable,
heatmapNumeric = heatmapNumeric
)
return(returnList)
}
seq(0,1,0.1)
seq(0,1,0.1)[10]
getQuantileTablesFromReferenceExpression(tpmReference, "TPM", 10, seq(0,1,0.1))[[3]]
libraryVector <- c("ggplot2", "reshape2", "dplyr")
sapply(libraryVector, library, character.only = TRUE)
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
load("./env/03_k5/01_run_script.RData")
#------------------
# helper functions
#------------------
# FROM EXPRESSION, GET SIMPLIFIED THRESHOLD PLOT
getQuantileTablesFromReferenceExpression <- function(
expressionTable, heatmapNumericScaleName, quantileThresholdIndex=4,
quantileSeq=seq(0,1,0.25)){
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileThreshold <-
quantile(ci, probs=quantileSeq)[quantileThresholdIndex]
labelColumnValues <- ifelse(
ci >= quantileThreshold, TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
rownames(numericTable) <-
rownames(booleanTable) <- rownames(expressionTable)
# heatmaps
heatmapNumeric <- Heatmap(
numericTable, name = heatmapNumericScaleName)
# return
returnList <- list(
booleanTable = booleanTable,
numericTable = numericTable,
heatmapNumeric = heatmapNumeric
)
return(returnList)
}
# FROM EXPRESSION GET PCA
#
getQuantileTablesFromReferenceExpression(
tpmReference, "TPM", 10, seq(0,1,0.1))[[3]]
getQuantileTablesFromReferenceExpression(
scaleTpmReference, "Z TPM", 10, seq(0,1,0.1))[[3]]
getQuantileTablesFromReferenceExpression(
log2TpmReference, "log2 TPM", 10, seq(0,1,0.1))[[3]]
getQuantileTablesFromReferenceExpression(
scaleLog2TpmZref, "Z log2 TPM", 10, seq(0,1,0.1))[[3]]
libraryVector <- c("ggplot2", "reshape2", "dplyr")
sapply(libraryVector, library, character.only = TRUE)
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
load("./env/03_k5/01_run_script.RData")
#---------------
#------------------
# helper functions
#------------------
# FROM EXPRESSION, GET SIMPLIFIED THRESHOLD PLOT
getQuantileTablesFromReferenceExpression <- function(
expressionTable, heatmapNumericScaleName, quantileThresholdIndex=4,
quantileSeq=seq(0,1,0.25)){
# boolean matrix
booleanTable <- apply(tpmReference, 2, function(ci){
quantileThreshold <-
quantile(ci, probs=quantileSeq)[quantileThresholdIndex]
labelColumnValues <- ifelse(
ci >= quantileThreshold, TRUE, FALSE)
return(labelColumnValues)
})
# numeric matrix
numericTable <- matrix(
as.numeric(booleanTable), nrow = nrow(booleanTable))
# format
colnames(numericTable) <-
colnames(booleanTable) <- colnames(expressionTable)
rownames(numericTable) <-
rownames(booleanTable) <- rownames(expressionTable)
# heatmaps
heatmapNumeric <- Heatmap(
numericTable, name = heatmapNumericScaleName)
# return
returnList <- list(
booleanTable = booleanTable,
numericTable = numericTable,
heatmapNumeric = heatmapNumeric
)
return(returnList)
}
# FROM EXPRESSION GET PCA
#
Heatmap(tpmReference, name = "TPM")
Heatmap(scaleTpmReference, name = "Z TPM")
Heatmap(log2TpmReference, name = "log2 TPM")
Heatmap(scaleLog2TpmReference, name = "Z log2 TPM")
getQuantileTablesFromReferenceExpression(
tpmReference, "TPM", 10, seq(0,1,0.1))[[3]]
getQuantileTablesFromReferenceExpression(
scaleTpmReference, "Z TPM", 10, seq(0,1,0.1))[[3]]
getQuantileTablesFromReferenceExpression(
log2TpmReference, "log2 TPM", 10, seq(0,1,0.1))[[3]]
getQuantileTablesFromReferenceExpression(
scaleLog2TpmZref, "Z log2 TPM", 10, seq(0,1,0.1))[[3]]
