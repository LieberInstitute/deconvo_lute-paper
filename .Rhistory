c("glial" = s.glial.series[index1], "neuron" = s.neuron.series[index2])
}))
})) %>% as.data.frame()
#plot(dfs.series$glial, dfs.series$neuron)
return(dfs.series)
}
# get bias computations in parallel (THIS SCRIPT, AND A FEW OTHERS)
parallel_bias_matched <- function(sce, yunadj, dfs, df.true = NULL,
celltype.variable = "k2", assay.name = "counts",
s.vector.ypb = c("glial" = 3, "neuron" = 10)){
# begin parallel
cl <- makeCluster(detectCores())
registerDoParallel(cl)
# get full run
if(is(yunadj, "RangedSummarizedExperiment")){
yunadj <- assays(yunadj)[[1]] %>% as.matrix()
}
df.res <- do.call(rbind,
mclapply(seq(nrow(dfs)),
function(i){
s.vector <- c("glial" = dfs$glial[i], "neuron" = dfs$neuron[i])
suppressMessages(
lute(sce, y = yunadj, celltype.variable = celltype.variable, s = s.vector,
typemarker.algorithm = NULL)$deconvolution.results@predictions.table
)
}))
colnames(df.res) <- paste0(colnames(df.res), ".pred.nnls")
df.res <- cbind(df.res, dfs)
if(is(df.true, "NULL")){
df.true <- sce[[celltype.variable]] %>% table() %>% prop.table() %>% as.data.frame()
rownames(df.true) <- df.true[,1]
}
df.res$glial.true <- as.numeric(df.true["glial",1])
df.res$neuron.true <- as.numeric(df.true["neuron",1])
df.res$bias.glial.true.pred <- df.res$glial.true - df.res$glial.pred.nnls
df.res$bias.neuron.true.pred <- df.res$neuron.true - df.res$neuron.pred.nnls
# make sequential again (i.e. cancels parallel)
registerDoSEQ()
return(df.res)
}
multigroup_bias_matched <- function(sample.id.vector, df.true.list, y.unadj, dfs, sce,
y.group.name = "batch.id2",
celltype.variable = "k2", assay.name = "counts",
s.vector.ypb = c("glial" = 3, "neuron" = 10)){
df.res <- do.call(rbind, lapply(sample.id.vector, function(sample.id){
y.iter <- y.unadj[,colData(y.unadj)[,y.group.name]==sample.id]
df.true.iter <- df.true.list[[sample.id]] %>% t() %>% as.data.frame()
#colnames(df.true.iter.transpose) <- colnames(df.true.list[[sample.id]])
df.res.iter <- parallel_bias_matched(sce, y.iter, dfs[seq(2),], df.true.iter,
celltype.variable, assay.name, s.vector.ypb)
df.res.iter$sample.id <- sample.id
return(df.res.iter)
}))
return(df.res)
}
# get true cell proportions info
rnascope_cell_info <- function(df.rn, sample.id = NULL, k.type = NULL, cell.types = NULL){
#
#
# get cell info data from summary df
#
# example:
# df.rn <- mae[["df.cellstat.rnascope"]]
# ct.info <- rnascope_cell_info(df.rn, "k2", c("glial", "neuron"))
#
filter.vector <- colnames(df.rn)
filter.condition.vector <- rep(TRUE, length(filter.vector))
ct.string <- paste0(cell.types, collapse = "|")
if(!is(ct.string, "NULL")){
filter.condition.vector <- filter.condition.vector & grepl(ct.string, filter.vector)
}
if(!is(sample.id, "NULL")){
filter.condition.vector <- filter.condition.vector & grepl(sample.id, filter.vector)
}
if(!is(k.type, "NULL")){
filter.condition.vector <- filter.condition.vector & grepl(k.type, filter.vector)
}
df.ct <- df.rn[,filter.condition.vector]
return(df.ct)
}
df.true.list <- function(df.rn, sample.id.vector, k.type, cell.types, info = "true_proportion"){
#
#
# example:
# sample.id.vector <- unique(y.unadj$batch.id2)
# list.dftrue <- df.true.list(df.rn, sample.id.vector, "k2", c("glial", "neuron"))
# names(list.dftrue) <- sample.id.vector
#
# NOTE: does not check cell type label order .. expect 1. glial, 2. neuron !!!
#
list.dfinfo <- lapply(sample.id.vector, function(sample.id){
rnascope_cell_info(df.rn, sample.id, k.type, cell.types)
})
list.dfinfo <- lapply(list.dfinfo, function(dfinfo){
dfinfo <- as.data.frame(dfinfo["true_proportion",,drop=F])
colnames(dfinfo) <- cell.types
return(dfinfo)
})
names(list.dfinfo) <- sample.id.vector
return(list.dfinfo)
}
#----------
# load data
#----------
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_with-rpkm_additional-data_final.rda"
mae.final.filepath <- file.path("deconvo_method-paper", "outputs", "01_prepare-datasets", new.mae.filename)
mae <- get(load(mae.final.filepath))
sce <- mae[["sn1.rnaseq"]]
y.unadj <- mae[["bulk.rnaseq"]]
#----------------------------------
# get s vector series (THIS SCRIPT)
#----------------------------------
dfs <- dfs.series()
#---------------------------------
# define the true cell proportions
#---------------------------------
df.rn <- mae[["df.cellstat.rnascope"]]
sample.id.vector <- unique(y.unadj$batch.id2)
list.df.true <- df.true.list(df.rn, sample.id.vector, "k2", c("glial", "neuron"))
names(list.df.true) <- sample.id.vector
#------------------------------------
# define the common z for experiments
#------------------------------------
sample.id <- "Br8492_post"
sce <- sce[,sce$Sample == sample.id]
#------------
# main script
#------------
# set params (SEE PROJECT NOTES)
assay.name <- "counts"
celltype.variable <- "k2"
sample.id.variable <- "Sample"
sample.id.vector <- unique(sce[[sample.id.variable]])
# this is the chunk that makes the results df (CHECK CRUCIAL NOTES)
sample.id.vector <- unique(y.unadj$batch.id2)
df.res.samples <- multigroup_bias_matched(sample.id.vector, list.df.true, y.unadj, dfs, sce)
#df.res.samples <- parallel_bias_matched(sce, y.unadj, dfs, df.true,
#                                        celltype.variable = celltype.variable,
#                                        assay.name = assay.name)
# append coldata from y.unadj (see MAE data)
df.res.samples$sample.labels <- rep(colnames(y.unadj), nrow(dfs))
dim9dfs
dim(dfs)
dim(dfs)
dim(df.res.samples)
gc()
#!/usr/bin/env R
# Author: Sean Maden
#
# Get full run of bias predictions.
#
# CRUCIAL NOTES, READ THIS:
#   * Z is the same across experiments
#   * Y is different across experiments
#
libv <- c("snow", "dplyr", "parallel", "doParallel", "lute", "dplyr")
sapply(libv, library, character.only = T)
#------
# setup
#------
# helper functions
# get series of s cell size factors (THIS SCRIPT, AND A FEW OTHERS)
dfs.series <- function(s.glial.series = seq(1, 20, 1)){
s.neuron.series <- rev(s.glial.series)
dfs.series <- do.call(rbind, lapply(seq(length(s.glial.series)), function(index1){
do.call(rbind, lapply(seq(length(s.neuron.series)), function(index2){
c("glial" = s.glial.series[index1], "neuron" = s.neuron.series[index2])
}))
})) %>% as.data.frame()
#plot(dfs.series$glial, dfs.series$neuron)
return(dfs.series)
}
# parallel_bias_matched
# get bias computations in parallel (THIS SCRIPT, AND A FEW OTHERS)
parallel_bias_matched <- function(sce, yunadj, dfs, df.true = NULL,
celltype.variable = "k2", assay.name = "counts",
s.vector.ypb = c("glial" = 3, "neuron" = 10)){
# begin parallel
cl <- makeCluster(detectCores())
registerDoParallel(cl)
# get full run
if(is(yunadj, "RangedSummarizedExperiment")){
yunadj <- assays(yunadj)[[1]] %>% as.matrix()
}
df.res <- do.call(rbind,
mclapply(seq(nrow(dfs)),
function(i){
s.vector <- c("glial" = dfs$glial[i], "neuron" = dfs$neuron[i])
suppressMessages(
lute(sce, y = yunadj, celltype.variable = celltype.variable, s = s.vector,
typemarker.algorithm = NULL)$deconvolution.results@predictions.table
)
}))
colnames(df.res) <- paste0(colnames(df.res), ".pred.nnls")
df.res <- cbind(df.res, dfs)
if(is(df.true, "NULL")){
df.true <- sce[[celltype.variable]] %>% table() %>% prop.table() %>% as.data.frame()
rownames(df.true) <- df.true[,1]
}
df.res$glial.true <- as.numeric(df.true["glial",1])
df.res$neuron.true <- as.numeric(df.true["neuron",1])
df.res$bias.glial.true.pred <- df.res$glial.true - df.res$glial.pred.nnls
df.res$bias.neuron.true.pred <- df.res$neuron.true - df.res$neuron.pred.nnls
# make sequential again (i.e. cancels parallel)
registerDoSEQ()
return(df.res)
}
# multigroup_bias_matched
# wraps parallel_bias_matched for multiple groups, uses df.true.list
multigroup_bias_matched <- function(sample.id.vector, df.true.list, y.unadj, dfs, sce,
y.group.name = "batch.id2",
celltype.variable = "k2", assay.name = "counts",
s.vector.ypb = c("glial" = 3, "neuron" = 10)){
df.res <- do.call(rbind, lapply(sample.id.vector, function(sample.id){
y.iter <- y.unadj[,colData(y.unadj)[,y.group.name]==sample.id]
df.true.iter <- df.true.list[[sample.id]] %>% t() %>% as.data.frame()
#colnames(df.true.iter.transpose) <- colnames(df.true.list[[sample.id]])
df.res.iter <- parallel_bias_matched(sce, y.iter, dfs, df.true.iter,
celltype.variable, assay.name, s.vector.ypb)
df.res.iter$sample.id <- sample.id
return(df.res.iter)
}))
return(df.res)
}
# get true cell proportions info
rnascope_cell_info <- function(df.rn, sample.id = NULL, k.type = NULL, cell.types = NULL){
#
#
# get cell info data from summary df
#
# example:
# df.rn <- mae[["df.cellstat.rnascope"]]
# ct.info <- rnascope_cell_info(df.rn, "k2", c("glial", "neuron"))
#
filter.vector <- colnames(df.rn)
filter.condition.vector <- rep(TRUE, length(filter.vector))
ct.string <- paste0(cell.types, collapse = "|")
if(!is(ct.string, "NULL")){
filter.condition.vector <- filter.condition.vector & grepl(ct.string, filter.vector)
}
if(!is(sample.id, "NULL")){
filter.condition.vector <- filter.condition.vector & grepl(sample.id, filter.vector)
}
if(!is(k.type, "NULL")){
filter.condition.vector <- filter.condition.vector & grepl(k.type, filter.vector)
}
df.ct <- df.rn[,filter.condition.vector]
return(df.ct)
}
df.true.list <- function(df.rn, sample.id.vector, k.type, cell.types, info = "true_proportion"){
#
#
# example:
# sample.id.vector <- unique(y.unadj$batch.id2)
# list.dftrue <- df.true.list(df.rn, sample.id.vector, "k2", c("glial", "neuron"))
# names(list.dftrue) <- sample.id.vector
#
# NOTE: does not check cell type label order .. expect 1. glial, 2. neuron !!!
#
list.dfinfo <- lapply(sample.id.vector, function(sample.id){
rnascope_cell_info(df.rn, sample.id, k.type, cell.types)
})
list.dfinfo <- lapply(list.dfinfo, function(dfinfo){
dfinfo <- as.data.frame(dfinfo["true_proportion",,drop=F])
colnames(dfinfo) <- cell.types
return(dfinfo)
})
names(list.dfinfo) <- sample.id.vector
return(list.dfinfo)
}
#----------
# load data
#----------
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_with-rpkm_additional-data_final.rda"
mae.final.filepath <- file.path("deconvo_method-paper", "outputs", "01_prepare-datasets", new.mae.filename)
mae <- get(load(mae.final.filepath))
sce <- mae[["sn1.rnaseq"]]
y.unadj <- mae[["bulk.rnaseq"]]
#----------------------------------
# get s vector series (THIS SCRIPT)
#----------------------------------
dfs <- dfs.series()
#---------------------------------
# define the true cell proportions
#---------------------------------
df.rn <- mae[["df.cellstat.rnascope"]]
sample.id.vector <- unique(y.unadj$batch.id2)
list.df.true <- df.true.list(df.rn, sample.id.vector, "k2", c("glial", "neuron"))
names(list.df.true) <- sample.id.vector
#------------------------------------
# define the common z for experiments
#------------------------------------
sample.id <- "Br8492_post"
sce <- sce[,sce$Sample == sample.id]
#------------
# main script
#------------
# set params (SEE PROJECT NOTES)
assay.name <- "counts"
celltype.variable <- "k2"
sample.id.variable <- "Sample"
sample.id.vector <- unique(sce[[sample.id.variable]])
# this is the chunk that makes the results df (CHECK CRUCIAL NOTES)
sample.id.vector <- unique(y.unadj$batch.id2)
df.res.samples <- multigroup_bias_matched(sample.id.vector, list.df.true, y.unadj, dfs, sce)
#df.res.samples <- parallel_bias_matched(sce, y.unadj, dfs, df.true,
#                                        celltype.variable = celltype.variable,
#                                        assay.name = assay.name)
# append coldata from y.unadj (see MAE data)
df.res.samples$sample.labels <- rep(colnames(y.unadj), nrow(dfs))
df.res.samples$sample.id <- rep(gsub("_.*", "", y.unadj$batch.id), nrow(dfs))
df.res.samples$cell.compartment <- rep(y.unadj$expt_condition, nrow(dfs))
df.res.samples$anatomic.region <- rep(y.unadj$location, nrow(dfs))
df.res.samples$library.preparation <- rep(y.udnadj$library_prep, nrow(dfs))
df.res.samples$library.preparation <- rep(y.unadj$library_prep, nrow(dfs))
df.res.samples$sample.id.brnum <- rep(y.unadj$batch.id2, nrow(dfs))
# append data transformations
# this is the chunk that sets more operants in `df.res`
df.res.samples$s.fraction.neuron.glial <- df.res.samples$neuron/df.res.samples$glial
df.res.samples$log.s.fraction <- log(df.res.samples$s.fraction.neuron.glial)
df.res.samples$minimum.error <- df.res.samples$error.neuron==min(df.res.samples$minimum.error)
df.res.samples$s.fraction.neuron.glial <- df.res.samples$neuron/df.res.samples$glial
df.res.samples$log.s.fraction <- log(df.res.samples$s.fraction.neuron.glial)
df.res.samples$minimum.error <- df.res.samples$error.neuron==min(df.res.samples$error.neuron)
min(df.res.samples$error.neuron)
max(df.res.samples$error.neuron)
head(df.res.samples)
summary(df.res.samples$bias.neuron.true.pred)
min(df.res.samples$bias.neuron.true.pred)
summary(df.res.samples$error.neuron)
df.res.samples$s.fraction.neuron.glial <- df.res.samples$neuron/df.res.samples$glial
df.res.samples$log.s.fraction <- log(df.res.samples$s.fraction.neuron.glial)
df.res.samples$error.neuron <- abs(df.res.samples$bias.neuron.true.pred)
df.res.samples$error.glial <- abs(df.res.samples$bias.glial.true.pred)
df.res.samples$minimum.error <- df.res.samples$error.neuron==min(df.res.samples$error.neuron)
df.res.samples$maximum.error <- df.res.samples$error.neuron==max(df.res.samples$error.neuron)
deciles.error.neuron <- quantile(df.res.samples$error.neuron, seq(0, 1, 0.1))
df.res.samples$minimum.decile.error <- df.res.samples$error.neuron <= deciles.error.neuron[2]
df.res.samples$maximum.decile.error <- df.res.samples$error.neuron >= deciles.error.neuron[9]
df.res.samples$error.neuron <- df.res.samples$bias.neuron.true.pred %>% abs()
head(df.res.samples)
# save
save.filename <- "df-sopt-result_yvary-zsame_cohort1.rda"
save.path <- file.path("deconvo_method-paper", "outputs",
"12_soptimize_yvary-zsame_dlpfc-cohort1", save.filename)
save(df.res.samples, file = save.path)
libv <- c("ggplot2", "dplyr")
sapply(libv, library, character.only = T)
knitr::opts_chunk$set(echo = TRUE)
# load results
setwd("..")
setwd("..")
load.filename <- "df-sopt-result_yvary-zsame_cohort1.rda"
load.path <- file.path("outputs", "12_soptimize_yvary-zsame_dlpfc-cohort1", load.filename)
df.res <- get(load(load.path))
# postprocess df.res
df.res$s.fraction.neuron.glial <- df.res$neuron/df.res$glial
df.res$s.fraction.neuron.glial.discrete <- as.character(round(df.res$s.fraction.neuron.glial, 2))
df.res$log.s.fraction <- log(df.res$s.fraction.neuron.glial)
df.res$minimum.error <- df.res$error.neuron==min(df.res$minimum.error)
df.res$maximum.error <- df.res$error.neuron==max(df.res$maximum.error)
deciles.error.neuron <- quantile(df.res$error.neuron, seq(0, 1, 0.1))
df.res$minimum.decile.error <- df.res$error.neuron <= deciles.error.neuron[2]
df.res$maximum.decile.error <- df.res$error.neuron >= deciles.error.neuron[9]
df.res$glial.group.label <- as.character(df.res$glial)
df.res$neuron.group.label <- as.character(df.res$neuron)
# df.res$all.highlight.categories <- ifelse(df.res$minimum.error, "min",ifelse(,,ifelse(,,ifelse())))
df.res$all.highlight.categories <- ifelse(df.res$minimum.error, "min",
ifelse(df.res$maximum.error, "max",
ifelse(df.res$minimum.decile.error, "min.dec",
ifelse(df.res$maximum.decile.error, "max.dec", "mid"))))
df.res$all.highlight.sizes <- ifelse(df.res$minimum.error|df.res$maximum.error, "min/max", "min.dec/max.dec/mid")
# set standard column labels
df.res$cell.compartment.id <- df.res$library.preparation
df.res$library.preparation.id <- gsub(".*_", "", df.res$cell.compartment)
df.res$block.id <- df.res$sample.id.brnum
df.res$experiment.id <- paste0(df.res$cell.compartment.id,"_",df.res$library.preparation.id)
df.res$sample.experiment <- paste0(df.res$sample.id,"_",df.res$experiment.id)
df.res$block.experiment <- paste0(df.res$block.id,"_",df.res$experiment.id)
df.res$sample.compartment <- paste0(df.res$sample.id,"_",df.res$cell.compartment.id)
# set plot parameters
highlight.color.low <- "red"
highlight.color.high <- "blue"
background.color.highlights <- "gray"
# helper functions
text.to.make.new.dfp <- function(variable.name="sample.id", value.index=1, dfp.index=1){
text.vector1 <- paste0("id.to.get <- df.res[,'",variable.name,"'][",value.index,"]")
text.vector2 <- paste0("filter.variable.vector <- df.res[,'",variable.name,"']==id.to.get")
text.vector3 <- paste0("dfp",dfp.index," <- df.res[filter.variable.vector,]")
text.vector.list <- as.list(c(text.vector1, text.vector2, text.vector3))
return(paste0(text.vector.list, collapse = ";"))
}
# viz wrapper functions
source("deconvo_plots.R")
# dataset summaries function(s)
source("dataset_summaries.R")
## Get plot data for `[BLOCK_ID]-[EXPERIMENT_CONDITION]`
# Gets the first ID in the "sample-region-compartment-library" designation, saves as `dfp1`.
dfp1 <- parse(text=text.to.make.new.dfp("block.experiment")) %>% eval()
## Get plot data for `[SAMPLE]-[EXPERIMENT_CONDITION]` "sample-compartment-library" as
dfp2 <- parse(text=text.to.make.new.dfp("sample.experiment")) %>% eval()
## Get plot data for `[SAMPLE]-[COMPARTMENT]`
dfp3 <- parse(text=text.to.make.new.dfp("sample.compartment")) %>% eval()
## Get plot data for `[SAMPLE]`
dfp4 <- parse(text=text.to.make.new.dfp("sample.id")) %>% eval()
list.summaries.dfp1 <- get_data_summaries(dfp1, "block.experiment")
list.summaries.dfp2 <- get_data_summaries(dfp2, "sample.experiment")
list.summaries.dfp3 <- get_data_summaries(dfp3, "sample.compartment")
list.summaries.dfp4 <- get_data_summaries(dfp4, "sample.id")
list.summaries.dfp1
list.summaries.dfp2
list.summaries.dfp3
list.summaries.dfp4
list.plots.dfp1 <- deconvo_plots_list(dfp1, "anatomic.region")
list.plots.dfp1$heatmaps$heatmap6
gc()
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
env.path <- file.path("outputs", "12_soptimize_yvary-zsame_dlpfc-cohort1", "env_yvar_notebook1.RData")
load(env.path)
hm <- unpack_plot_type(results.list.dfp4, "heatmap1", "heatmaps")
hm
names(hm)
hm <- unpack_plot_type(results.list.dfp1, "heatmap1", "heatmaps")[[1]]
hm
hm <- unpack_plot_type(results.list.dfp1, "heatmap1", "heatmaps")[[1]]
hm + geom_abline(slope = 3, yintercept = 0, lty = 2, size = 3)
hm <- unpack_plot_type(results.list.dfp1, "heatmap1", "heatmaps")[[1]]
hm + geom_abline(slope = 3, intercept = 0, lty = 2, size = 3)
?geom_abline
libv <- c("ggplot2", "dplyr")
sapply(libv, library, character.only = T)
knitr::opts_chunk$set(echo = TRUE)
hm <- unpack_plot_type(results.list.dfp1, "heatmap1", "heatmaps")[[1]]
hm + geom_abline(slope = 3, intercept = 0, lty = 2, size = 3)
names(mae)
knitr::opts_chunk$set(echo = TRUE)
libv <- c("ggplot2")
sapply(libv, library, character.only = T)
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_with-rpkm_additional-data_final.rda"
mae.final.filepath <- file.path("deconvo_method-paper", "outputs", "01_prepare-datasets", new.mae.filename)
mae <- get(load(mae.final.filepath))
setwd("..")
setwd("..")
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_with-rpkm_additional-data_final.rda"
mae.final.filepath <- file.path("deconvo_method-paper", "outputs", "01_prepare-datasets", new.mae.filename)
mae <- get(load(mae.final.filepath))
setwd("..")
setwd("..")
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_with-rpkm_additional-data_final.rda"
mae.final.filepath <- file.path("outputs", "01_prepare-datasets", new.mae.filename)
mae <- get(load(mae.final.filepath))
names(mae)
df.ct.info <- mae[["df.cellstat.rnascope"]]
df.ct.info
df.ct.info <- mae[["df.cellstat.rnascope"]]
neuron.size <- summary(as.numeric(df.ct.info["cell_size",grepl("neuron", colnames(df.ct.info))]))
glial.size <- summary(as.numeric(df.ct.info["cell_size",grepl("glial", colnames(df.ct.info))]))
neuron.size
glial.size
hm
df.ct.info <- mae[["df.cellstat.rnascope"]]
neuron.size <- median(as.numeric(df.ct.info["cell_size",grepl("neuron", colnames(df.ct.info))]))
glial.size <- median(as.numeric(df.ct.info["cell_size",grepl("glial", colnames(df.ct.info))]))
hm <- unpack_plot_type(results.list.dfp1, "heatmap1", "heatmaps")[[1]]
hm + geom_abline(slope = neuron.size/glial.size, intercept = 0, lty = 2, size = 3)
gc()
libv <- c("ggplot2", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
knitr::opts_chunk$set(echo = TRUE)
libv <- c("ggplot2", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
# load first notebook env
env.path <- file.path("outputs", "12_soptimize_yvary-zsame_dlpfc-cohort1", "env_yvar_notebook1.RData")
load(env.path)
# source script to get rnascope cell sizes
script.path <- file.path("code", "12_soptimize_yvary-zsame_dlpfc-cohort1", "02_prepare_rnascope_cellsize.R")
source(script.path)
setwd("..")
setwd("..")
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_with-rpkm_additional-data_final.rda"
mae.final.filepath <- file.path("outputs", "01_prepare-datasets", new.mae.filename)
mae <- get(load(mae.final.filepath))
libv <- c("ggplot2", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_with-rpkm_additional-data_final.rda"
mae.final.filepath <- file.path("outputs", "01_prepare-datasets", new.mae.filename)
mae <- get(load(mae.final.filepath))
setwd("C:/Users/User/Documents/GitHub/deconvo_method-paper")
libv <- c("ggplot2", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_with-rpkm_additional-data_final.rda"
mae.final.filepath <- file.path("outputs", "01_prepare-datasets", new.mae.filename)
mae <- get(load(mae.final.filepath))
# Get an RNAscope cell size estimate
df.ct.info <- mae[["df.cellstat.rnascope"]]
neuron.size <- median(as.numeric(df.ct.info["cell_size",grepl("neuron", colnames(df.ct.info))]))
glial.size <- median(as.numeric(df.ct.info["cell_size",grepl("glial", colnames(df.ct.info))]))
hm <- unpack_plot_type(results.list.dfp1, "heatmap1", "heatmaps")[[1]]
hm + geom_abline(slope = neuron.size/glial.size, intercept = 0, lty = 2, size = 3)
