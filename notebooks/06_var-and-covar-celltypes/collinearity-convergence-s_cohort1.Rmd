---
title: "collinearity-convergence-s_cohort2"
author: "Sean Maden"
date: "2023-07-25"
output: html_document
---

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
libv <- c("here", "reshape2")
sapply(libv, library, character.only = T)
```

Source datasets and functions.

```{r, include = FALSE}
ypb.cohort1.script.path <- "deconvo_method-paper/code/02_pseudobulk-predictions/01_only-k2_lute-pseudobulk-experiment_dlpfc-cohort1.R"
var.cohort1.script.path <- "deconvo_method-paper/code/06_var-and-covar-celltypes/01_var-and-covar_dlpfc-cohort1.R"
setwd("..")
source(ypb.cohort1.script.path, local = knitr::knit_global())
source(var.cohort1.script.path, local = knitr::knit_global())
```

# Show relation between S and reference quality

Define some series of s values.

```{r}
dfs <- data.frame(glial = c(seq(10), rep(10,10)), neuron = c(rep(10,10), seq(10)))
```

Correlation/collinearity

```{r}
list.results <- lapply(seq(nrow(dfs)), function(index){
  s.vector <- as.numeric(dfs[index,])
  names(s.vector) <- c("glial", "neuron")
  zlist.type <- z_list(sce, s.vector, assay.name = "logcounts", celltype.variable = "k2")
  zlist.donor <- z_list_bydonor(sce, sample.id.variable = "Sample", s.vector = s.vector, 
                           assay.name = "logcounts", celltype.variable = "k2")
  covcor.type <- covcor_from_zlist(zlist.type)
  covcor.donor <- covcor_from_zlist(zlist.donor)
  list(zlist.type = zlist.type, zlist.donor = zlist.donor, 
       covcor.type = covcor.type, covcor.donor = covcor.donor)
})
names(list.results) <- paste0("row", seq(nrow(dfs)))

# bind results
value.relation <- "covariance.diff.unadj.minus.adj"
colnames.vector <- c("cell.type.compare1", "cell.type.compare2", value.relation, "donor")
df.covar <- do.call(rbind, lapply(seq(length(list.results)), function(index){
  df.iter <- list.results[[index]][["covcor.donor"]][["lcov.diff.unadj.minus.adj"]] %>% melt()
  colnames(df.iter) <- colnames.vector
  df.iter$compare.label <- paste0(df.iter$cell.type.compare1, ";", df.iter$cell.type.compare2)
  # append s vector
  df.iter$s.iter <- paste0("s.set.",index)
  df.iter$s.neuron <- dfs$neuron[index]
  df.iter$s.glial <- dfs$glial[index]
  return(df.iter)
}))

# filter out variances (covar betw. identical variables) from covariances
filter.compare.label <- df.covar$compare.label %in% c("neuron;neuron", "glial;glial")
df.covar <- df.covar[!filter.compare.label,]
df.var <- df.covar[filter.compare.label,]
# remove redundant covarainces
df.covar <- df.covar[!df.covar$compare.label == "glial;neuron",]
```

Check if covariance changes for a single group across transformations (NOTE: if unchanging, likely there is bug in the above loop)

```{r}
summary(df.covar[df.covar$donor=="Br2720_mid",]$covariance.diff.unadj.minus.adj)
```

Summarize results

```{r}
ggplot(df.covar, aes(x = s.neuron, y = covariance.diff.unadj.minus.adj, color = donor)) + 
  geom_point() + geom_line() + theme_bw() + facet_wrap(~compare.label) 

ggplot(df.covar, aes(x = s.neuron, y = covariance.diff.unadj.minus.adj, color = compare.label)) + 
  geom_point() + geom_line() + theme_bw() + facet_wrap(~donor)

ggplot(df.covar, aes(x = compare.label, y = covariance.diff.unadj.minus.adj)) + 
  geom_jitter(alpha = 0.5) + geom_boxplot(color = 'cyan', alpha = 0) + 
  theme_bw() + facet_wrap(~donor) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Show extent of covariance change for just "glial;neuron"

```{r}
filter.df <- df.covar$compare.label=="glial;neuron"
df.filtered <- df.covar[filter.df,]

ggplot(df.filtered, 
       aes(x = compare.label, y = covariance.diff.unadj.minus.adj)) + 
  geom_jitter(alpha = 0.5) + geom_boxplot(color = 'cyan', alpha = 0) + 
  theme_bw() + facet_wrap(~donor) + theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(df.filtered, 
       aes(x = s.neuron, y = covariance.diff.unadj.minus.adj, color = donor)) + 
  geom_point() + geom_line() + theme_bw()
```

Variance vs. covariance

```{r}
```

# Define a convergence function

Pseudocode for convergence function:
* For a series of S normalization sets:
** Gets the correlation within and across cell types.
** Gets the correlation within and across donors.
** Perform a correlation comparison -- if its the same by cell type, try between donors. If its the same, 




