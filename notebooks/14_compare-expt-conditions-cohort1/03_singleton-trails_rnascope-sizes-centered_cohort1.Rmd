---
title: "03_singleton-trails_rnascope-size-based_cohort1"
author: "Sean Maden"
date: "2023-08-30"
output:
  pdf_document: default
  html_document: default
---

Repeats the analysis, centering search on RNAscope sizes and evaluating one sample at a time.

```{r setup, include=FALSE}
libv <- c("ggplot2", "dplyr", "scuttle", "MultiAssayExperiment", "SingleCellExperiment")
sapply(libv, library, character.only = T)
knitr::opts_chunk$set(echo = TRUE)
folder.name <- "14_compare-expt-conditions-cohort1"

setwd("..")
setwd("..")
env.path <- file.path("outputs", folder.name, 
                       "02_only-rnascope-sizes_compare-experiment-conditions-cohort1.RData")
load(env.path)
```

# K2, search by matched condition

```{r, eval = F, include = F}
# Gets search for single condition, single hyperparam set
expt.state <- "Nuc_polyA"
expt.var <- "expt_condition"
assay.name <- "logcounts"
group.name <- "sample.id"
yf.train <- y.train[,y.train[[expt.var]]==expt.state]
yf.validate <- y.validate[,y.validate[[expt.var]]==expt.state]
sample.id.vector <- c(unique(yf.train$sample.id)[1], unique(y.validate$sample.id)[1])
# search hyperparameters
sf.rn <- dfs.rn[dfs.rn$sample.id.dfs.rn == yf.train$sample.id[1],]
num.steps <- 35
s.step.validate <- 25
search.range.increment <- 8
s.search.min <- min(sf.rn[1:2])-search.range.increment
s.search.max <- max(sf.rn[1:2])+search.range.increment
s.search.step <- (s.search.max-s.search.min)/num.steps
dfsf.rn <- get_dfs(num.types = 2, min.size = s.search.min, 
                   max.size = s.search.max, size.step = s.search.step)
dfs.train <- dfsf.rn
colnames(dfs.train)[seq(2)] <- colnames(dfs.rn)[seq(2)]
dim(dfs.train)
# run experiment
list.expt <- get_soptimize_data_list(sce = sce, 
                                     sample.id.vector = sample.id.vector, 
                                     list.df.true = list.df.true, dfs = dfs.train,
                                      y.eset = y.unadj, y.train = y.train, 
                                      y.validate = y.validate, 
                                      assay.name = assay.name, 
                                      celltype.variable = k.variable.name, 
                                      group.name = group.name,
                                      matched.sce = TRUE)
###
# source(script.path) #  source latest script
###
crossval.unmatched.result <- 
    crossvalidate_soptimization(list.expt, s.step.validate = s.step.validate, 
                                validate.dfs = TRUE, plot.results = FALSE)
min(crossval.unmatched.result$df.res.train$error.glial.true.pred)
min(crossval.unmatched.result$df.res.validate$error.glial.true.pred)
```

Get results from a series of hyperparameter tests.

```{r, eval = F, include = F}
list.expt <- get_soptimize_data_list(sce = sce, 
                                     sample.id.vector = sample.id.vector, 
                                     list.df.true = list.df.true, dfs = dfs.train,
                                     y.eset = y.unadj, y.train = y.train, 
                                     y.validate = y.validate, 
                                     assay.name = assay.name, 
                                     celltype.variable = k.variable.name, 
                                     group.name = group.name,
                                     matched.sce = TRUE)

s.increment.range <- seq(1, 3, 1)
s.step.train.range <- seq(20, 100, 20)
s.step.validation.range <- seq(10, 20, 5)
hparam <- expand.grid(as.character(s.increment.range), 
                      as.character(s.step.train.range), 
                      as.character(s.step.validation.range))
colnames(hparam) <- c("s.range", "s.step.train", "s.step.validate")
for(c in seq(ncol(hparam))){hparam[,c] <- as.numeric(as.character(hparam[,c]))}
dim(hparam)

sf.rn <- dfs.rn[dfs.rn$sample.id.dfs.rn == yf.train$sample.id[1],]

df_hparam_result <- function(hparam, sf.rn, list.expt){
  # df_hparam_result
  # tests hyperparameters for s optimization cross-validation.
  # hparam: hyperparameters to test.
  # sf.rn: empirical s cell size scale factors to begin with.
  # list.expt: list of experiment data, metadata for crossvalidate_soptimization().
  #
  df.res.hparam <- do.call(rbind, lapply(seq(nrow(hparam)), function(index){
      message("working on hparam index: ", index)
      hparam.iter <- as.numeric(hparam[index,])
      search.range.increment <- hparam.iter[1]
      s.step.train <- hparam.iter[2]
      s.step.validate <- hparam.iter[3]
      s.search.min <- min(sf.rn[1:2])-search.range.increment
      s.search.max <- max(sf.rn[1:2])+search.range.increment
      s.search.step <- (s.search.max-s.search.min)/s.step.train
      dfs.train.iter <- get_dfs(num.types = 2, 
                                min.size = s.search.min,
                                max.size = s.search.max, 
                                size.step = s.search.step)
      colnames(dfs.train.iter)[seq(2)] <- names(sf.rn)[seq(2)]
      list.expt$dfs <- dfs.train.iter
      
      t1 <- Sys.time()
      crossval.unmatched.result <- 
        crossvalidate_soptimization(list.expt,
                                    s.step.validate = TRUE, 
                                    validate.dfs = TRUE, 
                                    plot.results = FALSE)
      time.elapsed <- Sys.time()-t1
      min.error.train <- min(crossval.unmatched.result$df.res.train$error.glial.true.pred)
      min.error.validate <- min(crossval.unmatched.result$df.res.validate$error.glial.true.pred)
      matrix(c(min.error.train, 
               min.error.validate, 
               hparam.iter, time.elapsed), nrow = 1)
    }))
  df.res.hparam <- as.data.frame(df.res.hparam)
  colnames(df.res.hparam) <- c("min.error.train", "min.error.validate", 
                                 "s.range", "s.step.train", "s.step.validate",
                               "time.elapsed.sec")
  return(df.res.hparam)
}

df.hparam.res <- df_hparam_result(hparam, sf.rn, list.expt)
save(df.hparam.res, file = "df-hparam-results_singleton-samples_s-optimize_cohort1.rda")
```

Plots with `s.range` on the x-axis.

```{r}
df.hparam.res.path <- "df-hparam-results_singleton-samples_s-optimize_cohort1.rda"
df.hparam.res <- get(load(df.hparam.res.path))

ggplot(df.hparam.res, aes(x = s.range, y = min.error.validate)) + 
  geom_point() + geom_line() + ggtitle("Hyperparameter: s.range")

ggplot(df.hparam.res, aes(x = s.range, y = min.error.validate)) + 
  geom_point() + geom_line() + ggtitle("Hyperparameter: s.range\nfacet: s.step.train") +
  facet_wrap(~s.step.train)

ggplot(df.hparam.res, aes(x = s.range, y = min.error.validate)) + 
  geom_point() + geom_line() + ggtitle("Hyperparameter: s.range\nfacet: s.step.validate") +
  facet_wrap(~s.step.validate)
```
Plots with `s.step.train` on the x-axis.

```{r}
ggplot(df.hparam.res, aes(x = s.step.train, y = min.error.validate, group = s.range)) + 
  geom_point() + geom_line() + ggtitle("Hyperparameter: s.step.train\nfacet: s.range") + 
  facet_wrap(~s.range)
```
Plots with `s.step.validate` on the x-axis.

```{r}
ggplot(df.hparam.res, aes(x = s.step.validate, y = min.error.validate)) + 
  geom_point() + geom_line() + ggtitle("Hyperparameter: s.step.validate\nfacet: s.range") +
  facet_wrap(~s.range)
```
Plots of `min.error.train` (x-axis) vs. `min.error.validate` (y-axis).

```{r}
ggplot(df.hparam.res, aes(x = min.error.train, y = min.error.validate)) + 
  geom_point() + geom_line() + ggtitle("Facet: s.range") +
  geom_abline(slope = 1, intercept = 0) +
  facet_wrap(~s.range)

ggplot(df.hparam.res, aes(x = min.error.train, y = min.error.validate)) + 
  geom_point() + geom_line() + ggtitle("Facet: s.range") +
  geom_abline(slope = 1, intercept = 0)
```

Plots with `time.elapsed` on the y-axis.

```{r}
```


