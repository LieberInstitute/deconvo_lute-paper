# train
s.increment.train <- (s.max.train-s.min.train)/num.steps.train
dfs.iter <- dfs.series(
seq(s.min.train, s.max.train, s.increment.train))
message("beginning training")
list.dfres.train <- get_sopt_results(mae.train, dfs.iter, "train")
# get dfs from train min.error coordinates
df.res.train <- list.dfres.train$df.res
min.error.neuron <- min(df.res.train$error.neuron)
message("min. error train: ", min.error.neuron)
filter.res <- df.res.train$error.neuron == min.error.neuron
s.train.neuron <- df.res.train[filter.res,]$s.neuron
s.train.glial <- df.res.train[filter.res,]$s.glial
s.vector.validate <- c(s.train.neuron, s.train.glial)
s.validate.min <- min(s.vector.validate)
s.validate.max <- max(s.vector.validate)
s.validate.increment <- (s.validate.max-s.validate.min)/num.steps.validate
s.validate.seq <- seq(s.validate.min, s.validate.max, s.validate.increment)
dfs.validate <- dfs.series(s.validate.seq)
# validate
message("beginning validation")
list.dfres.validate <- get_sopt_results(mae.validate, dfs.validate, "validate")
return(list(train.result = list.dfres.train,
validate.result = list.dfres.validate,
num.steps.train = num.steps.train))
}
seq.steps.train <- seq(5, 20, 2)
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps)
})
# get plot data
dfp <- do.call(rbind, lapply(list.cv, function(cv.result){
c(min(cv.result$validate.result$df.res$error.neuron), cv.result$num.steps.train)
}))
colnames(dfp) <- c("min.error.neuron.validate", "num.steps.train")
dfp
libv <- c("snow", "dplyr", "parallel", "doParallel", "lute", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
# sets variables
folder.name <- "04_experiment"
assay.name <- "counts"
# source
script.path <- file.path("scripts", folder.name, "00_param.R")
source(script.path)
source("./scripts/06_estimate/00_dataset_summaries.R")
source("./scripts/06_estimate/00_deconvo_plots.R")
#----------
# load data
#----------
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_allsamples.rda"
mae.final.filepath <- file.path("outputs", "01_mae", new.mae.filename)
mae <- get(load(mae.final.filepath))
# true proportions from sce data
sce.all <- mae[["snrnaseq.k2.all"]]
sample.id.vector <- unique(sce.all[["Sample"]])
list.df.true <- lapply(sample.id.vector, function(sample.id){
k.table <- table(sce.all[,sce.all[["Sample"]]==sample.id][["k2"]])
k.prop <- as.data.frame(t(as.matrix(prop.table(k.table))))
rownames(k.prop) <- "true_proportion"
return(k.prop)
})
names(list.df.true) <- sample.id.vector
#-------------------------------
# subset validation and training
#-------------------------------
train.sample.id <- get(load("./outputs/00_preprocess/list_snrnaseq_sampleid.rda"))[["train"]]
cd.mae <- colData(mae)
filter.mae.train <- cd.mae$sample.id %in% train.sample.id
mae.train <- mae[,filter.mae.train]
mae.validate <- mae[,!filter.mae.train]
rm(mae)
#-----------
# experiment
#-----------
# run experiment
seq.steps.train <- seq(5, 20, 2)[1:3]
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps)
})
libv <- c("snow", "dplyr", "parallel", "doParallel", "lute", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
# sets variables
script.path <- file.path("scripts", "06_experiment", "00_param.R")
source(script.path)
# sets variables
script.path <- file.path("scripts", "06_estimate", "00_param.R")
source(script.path)
source("./scripts/06_estimate/00_dataset_summaries.R")
source("./scripts/06_estimate/00_deconvo_plots.R")
libv <- c("snow", "dplyr", "parallel", "doParallel", "lute", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
# sets variables
script.path <- file.path("scripts", "06_estimate", "00_param.R")
source(script.path)
source("./scripts/06_estimate/00_dataset_summaries.R")
source("./scripts/06_estimate/00_deconvo_plots.R")
#----------
# load data
#----------
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_allsamples.rda"
mae.final.filepath <- file.path("outputs", "01_mae", new.mae.filename)
mae <- get(load(mae.final.filepath))
# true proportions from sce data
sce.all <- mae[["snrnaseq.k2.all"]]
sample.id.vector <- unique(sce.all[["Sample"]])
list.df.true <- lapply(sample.id.vector, function(sample.id){
k.table <- table(sce.all[,sce.all[["Sample"]]==sample.id][["k2"]])
k.prop <- as.data.frame(t(as.matrix(prop.table(k.table))))
rownames(k.prop) <- "true_proportion"
return(k.prop)
})
names(list.df.true) <- sample.id.vector
#-------------------------------
# subset validation and training
#-------------------------------
train.sample.id <- get(load("./outputs/00_preprocess/list_snrnaseq_sampleid.rda"))[["train"]]
cd.mae <- colData(mae)
filter.mae.train <- cd.mae$sample.id %in% train.sample.id
mae.train <- mae[,filter.mae.train]
mae.validate <- mae[,!filter.mae.train]
rm(mae)
#-----------
# experiment
#-----------
# run experiment
seq.steps.train <- seq(5, 20, 2)[1:3]
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps)
})
get_sopt_results <- function(mae, dfs, label = "train"){
# set params (SEE PROJECT NOTES)
assay.name <- "counts"
celltype.variable <- "k2"
sample.id.variable <- "Sample"
y.group.name <- 'batch.id2'
bulk.name <- "bulk.rnaseq"
sn.name <- "snrnaseq.k2.all"
# sample id vector
sample.id.vector <- unique(
intersect(
mae[[bulk.name]][[y.group.name]],
mae[[sn.name]][[sample.id.variable]]))
# iterate on training samples
list.res <- lapply(sample.id.vector, function(sample.id){
filter.mae <- colData(mae)$sample.id==sample.id
mae.iter <- mae[,filter.mae,]
message("Num. tests: ", nrow(dfs))
# seq
y.iter <- mae.iter[[bulk.name]]
sce.iter <- mae.iter[[sn.name]]
# results
multigroup_bias_matched(sample.id, list.df.true, y.iter,
y.group.name = y.group.name,
dfs, sce.iter,
assay.name = assay.name)
})
df.res <- do.call(rbind, lapply(list.res, function(item){item}))
df.res$crossvalidation <- label
summary(df.res.train$bias.neuron.true.pred)
# prepare and plot results
df.res <- dfres_postprocess(df.res.validate)
list.plots.dfres <- get_dfres_plots(df.res)
return(list(df.res = df.res, list.plots = list.plots.dfres))
}
get_crossvalidation_results <- function(mae.train, mae.validate,
num.steps.train = 10,
num.steps.validate = 50,
s.min.train = 1,
s.max.train = 40){
# train
s.increment.train <- (s.max.train-s.min.train)/num.steps.train
dfs <- dfs.series(
seq(s.min.train, s.max.train, s.increment.train))
message("beginning training")
list.dfres.train <- get_sopt_results(mae.train, dfs, "train")
# get dfs from train min.error coordinates
df.res.train <- list.dfres.train$df.res
min.error.neuron <- min(df.res.train$error.neuron)
message("min. error train: ", min.error.neuron)
filter.res <- df.res.train$error.neuron == min.error.neuron
s.train.neuron <- df.res.train[filter.res,]$s.neuron
s.train.glial <- df.res.train[filter.res,]$s.glial
s.vector.validate <- c(s.train.neuron, s.train.glial)
s.validate.min <- min(s.vector.validate)
s.validate.max <- max(s.vector.validate)
s.validate.increment <- (s.validate.max-s.validate.min)/num.steps.validate
s.validate.seq <- seq(s.validate.min, s.validate.max, s.validate.increment)
dfs.validate <- dfs.series(s.validate.seq)
# validate
message("beginning validation")
list.dfres.validate <- get_sopt_results(mae.validate, dfs.validate, "validate")
return(list(train.result = list.dfres.train,
validate.result = list.dfres.validate,
num.steps.train = num.steps.train))
}
libv <- c("snow", "dplyr", "parallel", "doParallel", "lute", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
# sets variables
script.path <- file.path("scripts", "06_estimate", "00_param.R")
source(script.path)
source("./scripts/06_estimate/00_dataset_summaries.R")
source("./scripts/06_estimate/00_deconvo_plots.R")
#----------
# load data
#----------
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_allsamples.rda"
mae.final.filepath <- file.path("outputs", "01_mae", new.mae.filename)
mae <- get(load(mae.final.filepath))
# true proportions from sce data
sce.all <- mae[["snrnaseq.k2.all"]]
sample.id.vector <- unique(sce.all[["Sample"]])
list.df.true <- lapply(sample.id.vector, function(sample.id){
k.table <- table(sce.all[,sce.all[["Sample"]]==sample.id][["k2"]])
k.prop <- as.data.frame(t(as.matrix(prop.table(k.table))))
rownames(k.prop) <- "true_proportion"
return(k.prop)
})
names(list.df.true) <- sample.id.vector
#-------------------------------
# subset validation and training
#-------------------------------
train.sample.id <- get(load("./outputs/00_preprocess/list_snrnaseq_sampleid.rda"))[["train"]]
cd.mae <- colData(mae)
filter.mae.train <- cd.mae$sample.id %in% train.sample.id
mae.train <- mae[,filter.mae.train]
mae.validate <- mae[,!filter.mae.train]
rm(mae)
#-----------
# experiment
#-----------
# run experiment
seq.steps.train <- seq(5, 20, 2)[1:3]
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps)
})
get_sopt_results <- function(mae, dfs, label = "train"){
# set params (SEE PROJECT NOTES)
assay.name <- "counts"
celltype.variable <- "k2"
sample.id.variable <- "Sample"
y.group.name <- 'batch.id2'
bulk.name <- "bulk.rnaseq"
sn.name <- "snrnaseq.k2.all"
# sample id vector
sample.id.vector <- unique(
intersect(
mae[[bulk.name]][[y.group.name]],
mae[[sn.name]][[sample.id.variable]]))
# iterate on training samples
list.res <- lapply(sample.id.vector, function(sample.id){
filter.mae <- colData(mae)$sample.id==sample.id
mae.iter <- mae[,filter.mae,]
message("Num. tests: ", nrow(dfs))
# seq
y.iter <- mae.iter[[bulk.name]]
sce.iter <- mae.iter[[sn.name]]
# results
multigroup_bias_matched(sample.id, list.df.true, y.iter,
y.group.name = y.group.name,
dfs, sce.iter,
assay.name = assay.name)
})
df.res <- do.call(rbind, lapply(list.res, function(item){item}))
df.res$crossvalidation <- label
# prepare and plot results
df.res <- dfres_postprocess(df.res)
list.plots.dfres <- get_dfres_plots(df.res)
return(list(df.res = df.res, list.plots = list.plots.dfres))
}
get_crossvalidation_results <- function(mae.train, mae.validate,
num.steps.train = 10,
num.steps.validate = 50,
s.min.train = 1,
s.max.train = 40){
# train
s.increment.train <- (s.max.train-s.min.train)/num.steps.train
dfs <- dfs.series(
seq(s.min.train, s.max.train, s.increment.train))
message("beginning training")
list.dfres.train <- get_sopt_results(mae.train, dfs, "train")
# get dfs from train min.error coordinates
df.res.train <- list.dfres.train$df.res
min.error.neuron <- min(df.res.train$error.neuron)
message("min. error train: ", min.error.neuron)
filter.res <- df.res.train$error.neuron == min.error.neuron
s.train.neuron <- df.res.train[filter.res,]$s.neuron
s.train.glial <- df.res.train[filter.res,]$s.glial
s.vector.validate <- c(s.train.neuron, s.train.glial)
s.validate.min <- min(s.vector.validate)
s.validate.max <- max(s.vector.validate)
s.validate.increment <- (s.validate.max-s.validate.min)/num.steps.validate
s.validate.seq <- seq(s.validate.min, s.validate.max, s.validate.increment)
dfs.validate <- dfs.series(s.validate.seq)
# validate
message("beginning validation")
list.dfres.validate <- get_sopt_results(mae.validate, dfs.validate, "validate")
return(list(train.result = list.dfres.train,
validate.result = list.dfres.validate,
num.steps.train = num.steps.train))
}
libv <- c("snow", "dplyr", "parallel", "doParallel", "lute", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
# sets variables
script.path <- file.path("scripts", "06_estimate", "00_param.R")
source(script.path)
source("./scripts/06_estimate/00_dataset_summaries.R")
source("./scripts/06_estimate/00_deconvo_plots.R")
#----------
# load data
#----------
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_allsamples.rda"
mae.final.filepath <- file.path("outputs", "01_mae", new.mae.filename)
mae <- get(load(mae.final.filepath))
# true proportions from sce data
sce.all <- mae[["snrnaseq.k2.all"]]
sample.id.vector <- unique(sce.all[["Sample"]])
list.df.true <- lapply(sample.id.vector, function(sample.id){
k.table <- table(sce.all[,sce.all[["Sample"]]==sample.id][["k2"]])
k.prop <- as.data.frame(t(as.matrix(prop.table(k.table))))
rownames(k.prop) <- "true_proportion"
return(k.prop)
})
names(list.df.true) <- sample.id.vector
#-------------------------------
# subset validation and training
#-------------------------------
train.sample.id <- get(load("./outputs/00_preprocess/list_snrnaseq_sampleid.rda"))[["train"]]
cd.mae <- colData(mae)
filter.mae.train <- cd.mae$sample.id %in% train.sample.id
mae.train <- mae[,filter.mae.train]
mae.validate <- mae[,!filter.mae.train]
rm(mae)
#-----------
# experiment
#-----------
# run experiment
seq.steps.train <- seq(5, 20, 2)[1:3]
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps)
})
libv <- c("snow", "dplyr", "parallel", "doParallel", "lute", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
# sets variables
script.path <- file.path("scripts", "06_estimate", "00_param.R")
source(script.path)
source("./scripts/06_estimate/00_dataset_summaries.R")
source("./scripts/06_estimate/00_deconvo_plots.R")
#----------
# load data
#----------
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_allsamples.rda"
mae.final.filepath <- file.path("outputs", "01_mae", new.mae.filename)
mae <- get(load(mae.final.filepath))
# true proportions from sce data
sce.all <- mae[["snrnaseq.k2.all"]]
sample.id.vector <- unique(sce.all[["Sample"]])
list.df.true <- lapply(sample.id.vector, function(sample.id){
k.table <- table(sce.all[,sce.all[["Sample"]]==sample.id][["k2"]])
k.prop <- as.data.frame(t(as.matrix(prop.table(k.table))))
rownames(k.prop) <- "true_proportion"
return(k.prop)
})
names(list.df.true) <- sample.id.vector
#-------------------------------
# subset validation and training
#-------------------------------
train.sample.id <- get(load("./outputs/00_preprocess/list_snrnaseq_sampleid.rda"))[["train"]]
cd.mae <- colData(mae)
filter.mae.train <- cd.mae$sample.id %in% train.sample.id
mae.train <- mae[,filter.mae.train]
mae.validate <- mae[,!filter.mae.train]
rm(mae)
#-----------
# experiment
#-----------
# run experiment
seq.steps.train <- seq(5, 20, 2)[1:3]
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps)
})
libv <- c("snow", "dplyr", "parallel", "doParallel", "lute", "dplyr", "MultiAssayExperiment")
sapply(libv, library, character.only = T)
# sets variables
script.path <- file.path("scripts", "06_estimate", "00_param.R")
source(script.path)
source("./scripts/06_estimate/00_dataset_summaries.R")
source("./scripts/06_estimate/00_deconvo_plots.R")
#----------
# load data
#----------
# load mae (SEE CODE 01 OUTPUTS)
new.mae.filename <- "mae_allsamples.rda"
mae.final.filepath <- file.path("outputs", "01_mae", new.mae.filename)
mae <- get(load(mae.final.filepath))
# true proportions from sce data
sce.all <- mae[["snrnaseq.k2.all"]]
sample.id.vector <- unique(sce.all[["Sample"]])
list.df.true <- lapply(sample.id.vector, function(sample.id){
k.table <- table(sce.all[,sce.all[["Sample"]]==sample.id][["k2"]])
k.prop <- as.data.frame(t(as.matrix(prop.table(k.table))))
rownames(k.prop) <- "true_proportion"
return(k.prop)
})
names(list.df.true) <- sample.id.vector
#-------------------------------
# subset validation and training
#-------------------------------
train.sample.id <- get(load("./outputs/00_preprocess/list_snrnaseq_sampleid.rda"))[["train"]]
cd.mae <- colData(mae)
filter.mae.train <- cd.mae$sample.id %in% train.sample.id
mae.train <- mae[,filter.mae.train]
mae.validate <- mae[,!filter.mae.train]
rm(mae)
#-----------
# experiment
#-----------
# run experiment
seq.steps.train <- seq(5, 20, 2)[1:3]
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps)
})
# get plot data
dfp <- do.call(rbind, lapply(list.cv, function(cv.result){
c(min(cv.result$validate.result$df.res$error.neuron), cv.result$num.steps.train)
}))
colnames(dfp) <- c("min.error.neuron.validate", "num.steps.train")
# plot results
ggplot(dfp, aes(x = steps.train, y = min.neuron.error.val)) + geom_point()
dfp
length(list.cv)
ggplot(dfp, aes(x = num.steps.train, y = min.error.neuron.validate)) + geom_point()
# get plot data
dfp <- do.call(rbind, lapply(list.cv, function(cv.result){
c(min(cv.result$validate.result$df.res$error.neuron), cv.result$num.steps.train)
}))
dfp <- as.data.frame(dfp)
colnames(dfp) <- c("min.error.neuron.validate", "num.steps.train")
# plot results
ggplot(dfp, aes(x = num.steps.train, y = min.error.neuron.validate)) + geom_point()
dfp
class(dfp$num.steps.train)
class(dfp$min.error.neuron.validate)
seq(5, 20, 2)
# run experiment
seq.steps.train <- seq(5, 20, 2)
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps)
})
# run experiment
seq.steps.train <- seq(5, 20, 2)
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps,
num.steps.validate = 10)
})
# run experiment
seq.steps.train <- seq(5, 20, 2)
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps,
num.steps.validate = 10)
})
# get plot data
dfp <- do.call(rbind, lapply(list.cv, function(cv.result){
c(min(cv.result$validate.result$df.res$error.neuron), cv.result$num.steps.train)
}))
dfp <- as.data.frame(dfp)
colnames(dfp) <- c("min.error.neuron.validate", "num.steps.train")
# plot results
ggplot(dfp, aes(x = num.steps.train, y = min.error.neuron.validate)) + geom_point()
seq.steps.train <- seq(5, 100, 5)
list.cv <- lapply(seq.steps.train, function(train.steps){
get_crossvalidation_results(
mae.train, mae.validate, num.steps.train = train.steps,
num.steps.validate = 10)
})
# get plot data
dfp <- do.call(rbind, lapply(list.cv, function(cv.result){
c(min(cv.result$validate.result$df.res$error.neuron), cv.result$num.steps.train)
}))
dfp <- as.data.frame(dfp)
colnames(dfp) <- c("min.error.neuron.validate", "num.steps.train")
# plot results
ggplot(dfp, aes(x = num.steps.train, y = min.error.neuron.validate)) + geom_point()
save.image("./outputs/06_estimate/01_run_script.RData")
save(list.cv, file = "./outputs/06_estimate/results_cv.rda")
save(dfp, file = "./outputs/06_estimate/results_dfp.rda")
names(list.cv)
names(list.cv[[1]])
head(list.cv[[1]]$train.result)
names(list.cv[[1]]$train.result)
length(list.cv)
dim(list.cv[[1]]$train.result$df.res)
dim(list.cv[[20]]$train.result$df.res)
names(list.cv[[1]])
list.cv.validate <- lapply(list.cv, function(item){
list(item$validate.result, num.steps.train = item$num.steps.train)
})
save(list.cv, file = "./outputs/06_estimate/results_cv_validate.rda")
