deconvolution.algorithm = data$metadata$deconvolution.algorithm,
list.df.true = data$list.df.true,
y.unadj = data$y.train,
dfs = data$dfs,
sce = data$sce,
assay.name = data$metadata$assay.name,
celltype.variable = data$metadata$celltype.variable,
y.group.name = data$metadata$group.name,
sce.group.name = data$metadata$group.name,
with.parallel = data$metadata$with.parallel,
matched.sce = data$metadata$matched.sce)
df.res$test.type <- "training"
df.res
})
df.res.train <- as.data.frame(df.res.all)
message("updating s search space...")
which.error.column <- which(grepl('^error\\..*', colnames(df.res.all)))[1]
error.vector <- df.res.all[,which.error.column]
min.decile.error <- as.numeric(quantile(error.vector)[[2]])
error.dec.filter <- error.vector <= min.decile.error
df.res.min <- df.res.all[error.dec.filter,]
min.s <- min(unlist(df.res.min[,grepl("^s\\..*", colnames(df.res.min))]))
max.s <- max(unlist(df.res.min[,grepl("^s\\..*", colnames(df.res.min))]))
unique.types <- unique(data$sce[[data$metadata$celltype.variable]])
num.types <- length(unique.types)
dfs.validate <- get_dfs(num.types,
min.size = min.s,
max.size = max.s,
size.step = (max.s-min.s)/s.step.validate)
colnames(dfs.validate) <- paste0("s.", unique.types)
lr <- list(df.res.train = df.res.train, dfs.validate = dfs.validate)
return(lr)
}
crossvalidate_validate <- function(data, dfs.validate){
#
# crossvalidate_validate
# data : experiment data object
# dfs.validate : dfs.validate returned by crossvalidate_train()
#
#
# parse validate
message("working on test type: validation")
df.res.all <- tryCatch({
df.res <- multigroup_bias_matched(sample.id.vector = data$sample.id.vector,
deconvolution.algorithm = data$metadata$deconvolution.algorithm,
list.df.true = data$list.df.true,
y.unadj = data$y.validate,
dfs = dfs.validate,
sce = data$sce,
assay.name = data$metadata$assay.name,
celltype.variable = data$metadata$celltype.variable,
y.group.name = data$metadata$group.name,
sce.group.name = data$metadata$group.name,
with.parallel = data$metadata$with.parallel,
matched.sce = data$metadata$matched.sce)
df.res$test.type <- "validation"
df.res
})
df.res.validate <- as.data.frame(df.res.all)
lr <- list(df.res.validate = df.res.validate)
return(lr)
}
crossvalidate_soptimization <- function(list.soptimize.data,
s.step.validate = 50,
facet.variable = NULL,
validate.dfs = TRUE,
update.stat.summaries = TRUE,
draw.min.err.line = TRUE,
plot.results = FALSE){
#
#
# crossvalidate_soptimization
#
# validate.dfs : whether to validate dfs based on training results.
#
#
# list.soptimize.data <- get_soptimize_data_list(num.types = 3, size.step = 2)
# crossvalidate.results <- crossvalidate_soptimization(list.soptimize.data)
# names(crossvalidate.results)
# crossvalidate.results$plot.list.results$`type1;type2`$heatmaps$heatmap1
# crossvalidate.results$plot.list.results$`type1;type2`$heatmaps$heatmap6
#
data <- list.soptimize.data
# parse training
train.result <- crossvalidate_train(data, s.step.validate)
# parse validation
if(validate.dfs){
dfs.for.validate <- train.result[["dfs.validate"]]
} else{
dfs.for.validate <- data$dfs
}
validate.result <- crossvalidate_validate(data, dfs.for.validate)
# return list
lr <- list(df.res.train = train.result[["df.res.train"]],
df.res.validate = validate.result[["df.res.validate"]])
if(plot.results){
# get results plots
lr[["plot.res.train"]] <- tryCatch({
deconvo_plots_list(df.res.train, facet.variable,
update.stat.summaries, draw.min.err.line)
})
lr[["plot.res.validate"]] <- tryCatch({
deconvo_plots_list(df.res.validate, facet.variable,
update.stat.summaries, draw.min.err.line)
})
}
return(lr)
}
kmatch_experiment <- function(k.variable.name = "k2",
sce = sce,
dfs.train = NULL,
validate.dfs = TRUE,
sample.id.vector = sample.id.vector,
list.df.true = list.df.true,
y.eset = y.unadj, y.train = y.train,
y.validate = y.validate,
assay.name = assay.name,
group.name = group.name,
plot.option = FALSE){
#
# validate.dfs : whether to update dfs based on training results.
#
k.cell.type.vector <- unique(sce[[k.variable.name]])
num.types <- length(k.cell.type.vector)
if(is(dfs.train, "NULL")){
# define dfs.train
dfs.train <- get_dfs(num.types, min.size = 1, max.size = 5, size.step = 1)
}
colnames(dfs.train) <- paste0("s.", k.cell.type.vector)
if(is(list.df.true, "NULL")){
y.sample.id.vector <- unique(y.unadj[[y.group.variable.name]])
list.df.true <- df.true.list(df.rn, y.sample.id.vector,
k.variable.name, k.cell.type.vector)
names(list.df.true) <- y.sample.id.vector
}
# Get experiment data
list.expt <- get_soptimize_data_list(sce = sce,
sample.id.vector = sample.id.vector,
list.df.true = list.df.true, dfs = dfs.train,
y.eset = y.unadj, y.train = y.train,
y.validate = y.validate,
assay.name = assay.name,
celltype.variable = k.variable.name,
group.name = group.name,
matched.sce = FALSE)
# get results
message("getting matched results...")
crossval.unmatched.result <-
crossvalidate_soptimization(list.expt, validate.dfs = validate.dfs, plot.results = plot.option)
message("getting unmatched results...")
list.expt$metadata$matched.sce <- TRUE
crossval.matched.result <-
crossvalidate_soptimization(list.expt, validate.dfs = validate.dfs, plot.results = plot.option)
# return
lr <- list(list.expt = list.expt,
crossval.unmatched.result = crossval.unmatched.result,
crossval.matched.result = crossval.matched.result)
return(lr)
}
kmatch_experiment_plots <- function(kmatch.expt.result){
# inspect results
df.matched <- kmatch.expt.result$crossval.matched.result$df.res.validate
df.unmatched <- kmatch.expt.result$crossval.unmatched.result$df.res.validate
# summarize
summary.matched.error <- summary(df.matched$error.neuron.true.pred)
summary.unmatched.error <- summary(df.unmatched$error.neuron.true.pred)
# plots -- tall
dfp.matched <- kmatch.expt.result$crossval.matched.result$plot.list.results[[1]]$dfp
dfp.unmatched <- kmatch.expt.result$crossval.unmatched.result$plot.list.results[[1]]$dfp
dfp.matched$group <- "matched"
dfp.unmatched$group <- "unmatched"
dfp <- rbind(dfp.matched, dfp.unmatched)
filter.dfp <- dfp$all.highlight.categories=="min.dec"
dfp <- dfp[filter.dfp,]
# violin plots
vp1 <- ggplot(dfp, aes(x = sample.id, y = error.value)) +
geom_violin(draw_quantiles = 0.5) + facet_wrap(~group, nrow = 2) +
theme(axis.text.x = element_text(angle = 45,hjust = 1))
# jitterbox plots
jb1 <- ggplot(dfp, aes(x = sample.id, y = error.value)) +
geom_jitter(alpha = 0.5) + geom_boxplot(alpha = 0, color = "cyan") +
facet_wrap(~group, nrow = 2) +
theme(axis.text.x = element_text(angle = 45,hjust = 1))
# plots -- wide
dfp <- data.frame(error.matched = dfp.matched$error.type1,
error.unmatched = dfp.unmatched$error.type1)
dfp$sample.id <- dfp.matched$sample.id
pt1 <- ggplot(dfp, aes(x = error.matched, y = error.unmatched)) +
geom_abline(slope = 1, intercept = 0) + geom_point() + facet_wrap("sample.id")
# filter min.dec.err.match
dfp$min.dec.err.match <- dfp.matched$minimum.decile.error
dfpf <- dfp[dfp$min.dec.err.match==T,]
pt2 <- ggplot(dfpf, aes(x = error.matched, y = error.unmatched)) +
geom_abline(slope = 1, intercept = 0) + geom_point() +
facet_wrap(~sample.id)
# filter min.dec.err.unmatch
dfp$min.dec.err.unmatch <- dfp.unmatched$minimum.decile.error
dfpf <- dfp[dfp$min.dec.err.unmatch==T,]
pt3 <- ggplot(dfpf, aes(x = error.matched, y = error.unmatched)) +
geom_abline(slope = 1, intercept = 0) + geom_point() +
facet_wrap(~sample.id)
# composite
mindecerr.matched <- dfp.matched$minimum.decile.error
mindecerr.unmatched <- dfp.unmatched$minimum.decile.error
pt4 <- dfp$category <- ifelse(mindecerr.matched & mindecerr.unmatched, "both",
ifelse(mindecerr.matched, "matched",
ifelse(mindecerr.unmatched, "unmatch", "high")))
pt5 <- ggplot(dfp, aes(x = error.matched, y = error.unmatched,
group = category, color = category)) +
geom_abline(slope = 1, intercept = 0) + geom_point() +
facet_wrap(~sample.id)
pt6 <- ggplot(dfp, aes(x = error.matched, y = error.unmatched,
group = category, color = category)) +
geom_abline(slope = 1, intercept = 0) + geom_point() +
facet_wrap(~category)
pt7 <- ggplot(dfp[dfp$category=="both",], aes(x = error.matched, y = error.unmatched,
group = category, color = category)) +
geom_abline(slope = 1, intercept = 0) + geom_point() +
facet_wrap(~sample.id)
lr <- list(summary.matched.error = summary.matched.error,
summary.unmatched.error = summary.unmatched.error,
vp1 = vp1, jb1 = jb1, pt1 = pt1, pt2 = pt2,
pt3 = pt3, pt4 = pt4, pt5 = pt5, pt6 = pt6,
pt7 = pt7)
return(lr)
}
gc()
#!/usr/bin/env R
#
# Test independent pseudobulk from DLPFC cohort1 snRNAseq data.
#
source("scripts/02_pseudobulk/00_parameters-pseudobulk.R")
#!/usr/bin/env R
#
# Test independent pseudobulk from DLPFC cohort1 snRNAseq data.
#
source("scripts/02_pseudobulk/00_param.R")
sapply(libv, library, character.only = T)
list.sce.markers <- get(load(sce.markers.list.path))
sce <- list.sce.markers$k3
s.vector <- c("Excit" = 10, "glial" = 3, "Inhib" = 10)
# get experiment results tables
dfp.tall <- get_ypb_experiment_series(sce, sample.id.variable = "Sample",
celltype.variable = "k3", assay.name = "logcounts",
s.vector = s.vector,
algorithm.name = "nnls", return.dimensions = "tall")
dfp.wide <- get_ypb_experiment_series(sce, sample.id.variable = "Sample",
celltype.variable = "k3", assay.name = "logcounts",
s.vector = s.vector,
algorithm.name = "nnls", return.dimensions = "wide")
dfp.ct <- dfp_tall_by_celltype(dfp.wide) # dfp.wide, tall by cell type
# make new plots
# plot proportions multipanel
ggplot(dfp.ct, aes(x = true.noscale, y = pred.noscale)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~celltype)
# jitterbox -- jittered points and boxplots of absolute errors
dfp.ae1 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.withscale)
dfp.ae1$type <- "withscale"
dfp.ae2 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.noscale)
dfp.ae2$type <- "noscale"
dfp.ae <- rbind(dfp.ae1, dfp.ae2)
ggplot(dfp.ae, aes(x = celltype, y = abs.error)) + geom_jitter(alpha = 0.5) +
geom_boxplot(color = "cyan", alpha = 0) + theme_bw() + facet_wrap(~type)
save.image("./env/02_pseudobulk/02_k3.RData")
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
list.files()
load("./env/02_pseudobulk/02_k3.RData")
new.plot <- ggplot(dfp.tall, aes(x = neuron.true, y = neuron.pred)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~type) + ggtitle("Neuron")
new.plot
dfp.tall
new.plot <- ggplot(dfp.tall, aes(x = neuron.true, y = neuron.pred)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~type) + ggtitle("Neuron")
new.plot
head(dfp.tall)
ggplot(dfp.ct, aes(x = true.noscale, y = pred.noscale)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~celltype)
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
list.files()
load("./env/02_pseudobulk/01_k2.RData")
new.plot <- ggplot(dfp.ct, aes(x = true.noscale, y = pred.noscale)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~celltype)
setwd("..")
setwd("..")
new.plot.name <- "figs1a.jpg"
jpeg(file.path("./figures/02_pseudobulk/", new.plot.name),
width = 4, height = 2.5, units = "in", res = 400)
new.plot
dev.off()
new.plot <- ggplot(dfp.ct, aes(x = true.noscale, y = pred.noscale)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~celltype)
new.plot
setwd("..")
setwd("..")
new.plot.name <- "fig2a.jpg"
jpeg(file.path("./figures/02_pseudobulk/", new.plot.name),
width = 6, height = 3, units = "in", res = 400)
new.plot
dev.off()
dfp.ae1 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.withscale)
dfp.ae1$type <- "withscale"
dfp.ae2 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.noscale)
dfp.ae2$type <- "noscale"
dfp.ae <- rbind(dfp.ae1, dfp.ae2)
new.plot <- ggplot(dfp.ae, aes(x = celltype, y = abs.error)) + geom_jitter(alpha = 0.5) +
geom_boxplot(color = "cyan", alpha = 0) + theme_bw() + facet_wrap(~type)
new.plot
new.plot <- ggplot(dfp.tall, aes(x = neuron.true, y = neuron.pred)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~type) + ggtitle("Neuron")
new.plot
setwd("..")
setwd("..")
new.plot.name <- "fig2c.jpg"
jpeg(file.path("./figures/02_pseudobulk/", new.plot.name),
width = 6, height = 3, units = "in", res = 400)
new.plot
dev.off()
# jitterbox -- jittered points and boxplots of absolute errors
dfp.ae1 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.withscale)
dfp.ae1$type <- "withscale"
dfp.ae2 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.noscale)
dfp.ae2$type <- "noscale"
dfp.ae <- rbind(dfp.ae1, dfp.ae2)
new.plot <- ggplot(dfp.ae, aes(x = celltype, y = abs.error)) +
geom_jitter(alpha = 0.5) +
geom_boxplot(color = "cyan", alpha = 0) + theme_bw() + facet_wrap(~type)
setwd("..")
setwd("..")
new.plot.name <- "figs1c.jpg"
jpeg(file.path("./figures/02_pseudobulk/", new.plot.name),
width = 4, height = 2.5, units = "in", res = 400)
new.plot
dev.off()
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
list.files()
load("./env/02_pseudobulk/02_k3.RData")
gc()
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
list.files()
load("./env/02_pseudobulk/02_k3.RData")
new.plot <- ggplot(dfp.ct, aes(x = true.noscale, y = pred.noscale)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~celltype)
new.plot
setwd("..")
setwd("..")
new.plot.name <- "fig2e.jpg"
jpeg(file.path("./figures/02_pseudobulk/", new.plot.name),
width = 6, height = 3, units = "in", res = 400)
new.plot
dev.off()
dfp.ae1 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.withscale)
dfp.ae1$type <- "withscale"
dfp.ae2 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.noscale)
dfp.ae2$type <- "noscale"
dfp.ae <- rbind(dfp.ae1, dfp.ae2)
new.plot <- ggplot(dfp.ae, aes(x = celltype, y = abs.error)) +
geom_jitter(alpha = 0.5) +
geom_boxplot(color = "cyan", alpha = 0) + theme_bw() + facet_wrap(~type)
setwd("..")
setwd("..")
new.plot.name <- "figs1e.jpg"
jpeg(file.path("./figures/02_pseudobulk/", new.plot.name),
width = 4, height = 2.5, units = "in", res = 400)
new.plot
dev.off()
setwd("..")
setwd("..")
new.plot.name <- "figs1e.jpg"
jpeg(file.path("./figures/02_pseudobulk/", new.plot.name),
width = 4, height = 2.5, units = "in", res = 400)
new.plot
dev.off()
gc()
knitr::opts_chunk$set(echo = TRUE)
setwd("..")
setwd("..")
list.files()
load("./env/02_pseudobulk/01_k2.RData")
new.plot <- ggplot(dfp.ct, aes(x = true.noscale, y = pred.noscale)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~celltype)
new.plot <- ggplot(dfp.ct, aes(x = true.noscale, y = pred.noscale)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~celltype)
#!/usr/bin/env R
#
# Test independent pseudobulk from DLPFC cohort1 snRNAseq data.
#
source(file.path("scripts", "02_pseudobulk", "00_param.R"))
sapply(libv, library, character.only = T)
list.sce.markers <- get(load(sce.markers.list.path))
sce.k2 <- list.sce.markers$k2
# get experiment results tables
dfp.tall <- get_ypb_experiment_series(sce.k2, sample.id.variable = "Sample",
celltype.variable = "k2", assay.name = "logcounts",
s.vector = c("glial" = 3, "neuron" = 10),
algorithm.name = "nnls", return.dimensions = "tall")
dfp.wide <- get_ypb_experiment_series(sce.k2, sample.id.variable = "Sample",
celltype.variable = "k2", assay.name = "logcounts",
s.vector = c("glial" = 3, "neuron" = 10),
algorithm.name = "nnls", return.dimensions = "wide")
# make new plots
# plot proportions panel -- no scale
ggplot(dfp.tall[dfp.tall$type=="noscale",],
aes(x = neuron.true, y = neuron.pred)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + ggtitle("Neuron")
# plot proportions multipanel -- scale vs with scale
ggplot(dfp.tall, aes(x = neuron.true, y = neuron.pred)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~type) + ggtitle("Neuron")
# jitterbox -- jittered points and boxplots of absolute errors
ggplot(dfp.tall, aes(x = type, y = neuron.abs.error)) + geom_jitter(alpha = 0.5) +
geom_boxplot(color = "cyan", alpha = 0) + theme_bw() + ggtitle("Neuron")
# save environment
save.image("./env/02_pseudobulk/01_k2.RData")
new.plot <- ggplot(dfp.tall, aes(x = type, y = neuron.abs.error)) +
geom_jitter(alpha = 0.5) +
geom_boxplot(color = "cyan", alpha = 0) + theme_bw() + ggtitle("Neuron")
setwd("..")
setwd("..")
new.plot.name <- "figs1a.jpg"
jpeg(file.path("./figures/02_pseudobulk/", new.plot.name),
width = 4, height = 2.5, units = "in", res = 400)
new.plot
dev.off()
#!/usr/bin/env R
#
# Test independent pseudobulk from DLPFC cohort1 snRNAseq data.
#
source("scripts/02_pseudobulk/00_param.R")
sapply(libv, library, character.only = T)
list.sce.markers <- get(load(sce.markers.list.path))
sce <- list.sce.markers$k3
s.vector <- c("Excit" = 10, "glial" = 3, "Inhib" = 10)
# get experiment results tables
dfp.tall <- get_ypb_experiment_series(sce, sample.id.variable = "Sample",
celltype.variable = "k3", assay.name = "logcounts",
s.vector = s.vector,
algorithm.name = "nnls", return.dimensions = "tall")
dfp.wide <- get_ypb_experiment_series(sce, sample.id.variable = "Sample",
celltype.variable = "k3", assay.name = "logcounts",
s.vector = s.vector,
algorithm.name = "nnls", return.dimensions = "wide")
dfp.ct <- dfp_tall_by_celltype(dfp.wide) # dfp.wide, tall by cell type
# make new plots
# plot proportions multipanel
ggplot(dfp.ct, aes(x = true.noscale, y = pred.noscale)) + geom_point() +
geom_abline(slope = 1, intercept = 0) +
geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0.5) + theme_bw() +
xlab("True proportion") + ylab("Predicted proportion") +
xlim(0, 1) + ylim(0, 1) + facet_wrap(~celltype)
# jitterbox -- jittered points and boxplots of absolute errors
dfp.ae1 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.withscale)
dfp.ae1$type <- "withscale"
dfp.ae2 <- data.frame(celltype = dfp.ct$celltype,
abs.error = dfp.ct$abs.error.noscale)
dfp.ae2$type <- "noscale"
dfp.ae <- rbind(dfp.ae1, dfp.ae2)
ggplot(dfp.ae, aes(x = celltype, y = abs.error)) + geom_jitter(alpha = 0.5) +
geom_boxplot(color = "cyan", alpha = 0) + theme_bw() + facet_wrap(~type)
# save environment
save.image("./env/02_pseudobulk/02_k3.RData")
